package com.gt.models.physics;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

/**
 * Advanced suspension system with multi-link geometry, anti-roll bars, and dynamic behavior
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class SuspensionSystem {
    // Spring characteristics
    private float frontSpringRate; // N/mm
    private float rearSpringRate; // N/mm
    private float frontPreload; // Spring preload in mm
    private float rearPreload; // Spring preload in mm

    // Damper characteristics
    private float frontDamperCompression; // Compression damping coefficient
    private float frontDamperRebound; // Rebound damping coefficient
    private float rearDamperCompression; // Compression damping coefficient
    private float rearDamperRebound; // Rebound damping coefficient

    // Anti-roll bars
    private float frontAntiRollBarRate; // Front anti-roll bar stiffness
    private float rearAntiRollBarRate; // Rear anti-roll bar stiffness
    private boolean frontAntiRollBarEnabled;
    private boolean rearAntiRollBarEnabled;

    // Geometry and positioning
    private float frontTravel; // Maximum suspension travel in mm
    private float rearTravel; // Maximum suspension travel in mm
    private float rideHeight; // Current ride height in mm
    private float frontCamberGain; // Camber change per mm of suspension travel
    private float rearCamberGain; // Camber change per mm of suspension travel
    private float frontToeChange; // Toe change per mm of suspension travel
    private float rearToeChange; // Toe change per mm of suspension travel

    // Dynamic state
    private float[] suspensionPosition; // Current position for each corner [FL, FR, RL, RR]
    private float[] suspensionVelocity; // Velocity for each corner
    private float[] suspensionForce; // Force generated by each corner
    private float[] camberAngles; // Dynamic camber angles
    private float[] toeAngles; // Dynamic toe angles

    // Advanced features
    private String suspensionType; // "macpherson", "double_wishbone", "multi_link", "solid_axle"
    private boolean adaptiveDampers; // Electronically controlled dampers
    private float adaptiveDamperSetting; // Current adaptive setting (0.0 = soft, 1.0 = firm)
    private boolean airSuspension; // Air suspension system
    private float airPressure; // Air spring pressure

    // Performance tuning
    private float bumpRubberRate; // Bump rubber spring rate
    private float reboundRubberRate; // Rebound rubber spring rate
    private float progressiveRate; // Progressive spring rate multiplier

    public SuspensionSystem() {
        // Default sport suspension setup
        this.frontSpringRate = 35000.0f; // N/m (35 kN/m)
        this.rearSpringRate = 40000.0f; // N/m (40 kN/m)
        this.frontPreload = 5.0f; // mm
        this.rearPreload = 5.0f; // mm

        this.frontDamperCompression = 2500.0f; // N*s/m
        this.frontDamperRebound = 3500.0f; // N*s/m
        this.rearDamperCompression = 3000.0f; // N*s/m
        this.rearDamperRebound = 4000.0f; // N*s/m

        this.frontAntiRollBarRate = 15000.0f; // N*m/rad
        this.rearAntiRollBarRate = 12000.0f; // N*m/rad
        this.frontAntiRollBarEnabled = true;
        this.rearAntiRollBarEnabled = true;

        this.frontTravel = 80.0f; // mm
        this.rearTravel = 75.0f; // mm
        this.rideHeight = 120.0f; // mm
        this.frontCamberGain = -0.8f; // degrees per 100mm travel
        this.rearCamberGain = -0.5f; // degrees per 100mm travel
        this.frontToeChange = 0.2f; // degrees per 100mm travel
        this.rearToeChange = -0.1f; // degrees per 100mm travel

        this.suspensionPosition = new float[4]; // All at neutral position
        this.suspensionVelocity = new float[4];
        this.suspensionForce = new float[4];
        this.camberAngles = new float[4];
        this.toeAngles = new float[4];

        this.suspensionType = "double_wishbone";
        this.adaptiveDampers = false;
        this.adaptiveDamperSetting = 0.5f;
        this.airSuspension = false;
        this.airPressure = 0.0f;

        this.bumpRubberRate = 100000.0f; // N/m
        this.reboundRubberRate = 80000.0f; // N/m
        this.progressiveRate = 1.2f;
    }

    /**
     * Update suspension forces and geometry
     * @param wheelLoads Array of vertical loads on each wheel [FL, FR, RL, RR]
     * @param wheelPositions Array of wheel world positions [FL, FR, RL, RR]
     * @param chassisPosition Chassis position and orientation
     * @param deltaTime Time step in seconds
     * @return Array of suspension forces [FL, FR, RL, RR]
     */
    public float[] updateSuspension(float[] wheelLoads, Vector3[] wheelPositions,
                                   Vector3 chassisPosition, float deltaTime) {
        float[] suspensionForces = new float[4];

        for (int i = 0; i < 4; i++) {
            // Calculate suspension compression
            float targetPosition = calculateTargetPosition(i, wheelLoads[i]);
            float displacement = targetPosition - suspensionPosition[i];

            // Update suspension position and velocity
            suspensionVelocity[i] = displacement / deltaTime;
            suspensionPosition[i] = targetPosition;

            // Calculate spring force
            float springForce = calculateSpringForce(i, suspensionPosition[i]);

            // Calculate damper force
            float damperForce = calculateDamperForce(i, suspensionVelocity[i]);

            // Calculate anti-roll bar force
            float antiRollForce = calculateAntiRollBarForce(i);

            // Combine forces
            suspensionForces[i] = springForce + damperForce + antiRollForce;

            // Update geometry (camber and toe)
            updateGeometry(i);

            // Apply bump and rebound limiters
            applyTravelLimits(i, suspensionForces);
        }

        return suspensionForces;
    }

    /**
     * Calculate target suspension position based on load
     */
    private float calculateTargetPosition(int corner, float wheelLoad) {
        float springRate = (corner < 2) ? frontSpringRate : rearSpringRate;
        float preload = (corner < 2) ? frontPreload : rearPreload;

        // Static deflection under load
        float staticDeflection = wheelLoad / springRate;

        return staticDeflection - preload;
    }

    /**
     * Calculate spring force with progressive rate
     */
    private float calculateSpringForce(int corner, float position) {
        float springRate = (corner < 2) ? frontSpringRate : rearSpringRate;
        float preload = (corner < 2) ? frontPreload : rearPreload;

        // Progressive spring rate
        float compression = Math.abs(position);
        float maxTravel = (corner < 2) ? frontTravel : rearTravel;
        float compressionRatio = compression / maxTravel;

        float effectiveRate = springRate * (1.0f + compressionRatio * (progressiveRate - 1.0f));

        return -effectiveRate * (position + preload);
    }

    /**
     * Calculate damper force with velocity-dependent characteristics
     */
    private float calculateDamperForce(int corner, float velocity) {
        float compressionDamping, reboundDamping;

        if (corner < 2) { // Front
            compressionDamping = frontDamperCompression;
            reboundDamping = frontDamperRebound;
        } else { // Rear
            compressionDamping = rearDamperCompression;
            reboundDamping = rearDamperRebound;
        }

        // Adaptive dampers
        if (adaptiveDampers) {
            float adaptiveMultiplier = 0.5f + adaptiveDamperSetting * 1.0f;
            compressionDamping *= adaptiveMultiplier;
            reboundDamping *= adaptiveMultiplier;
        }

        // Different damping for compression vs rebound
        if (velocity > 0) { // Compression
            return -compressionDamping * velocity;
        } else { // Rebound
            return -reboundDamping * velocity;
        }
    }

    /**
     * Calculate anti-roll bar force to resist body roll
     */
    private float calculateAntiRollBarForce(int corner) {
        if (!frontAntiRollBarEnabled && !rearAntiRollBarEnabled) {
            return 0.0f;
        }

        float antiRollForce = 0.0f;

        if (corner < 2 && frontAntiRollBarEnabled) { // Front axle
            float leftPosition = suspensionPosition[0]; // FL
            float rightPosition = suspensionPosition[1]; // FR
            float rollAngle = leftPosition - rightPosition; // Simplified roll calculation

            antiRollForce = -frontAntiRollBarRate * rollAngle * 0.5f;
            if (corner == 1) antiRollForce = -antiRollForce; // Opposite sign for right side

        } else if (corner >= 2 && rearAntiRollBarEnabled) { // Rear axle
            float leftPosition = suspensionPosition[2]; // RL
            float rightPosition = suspensionPosition[3]; // RR
            float rollAngle = leftPosition - rightPosition; // Simplified roll calculation

            antiRollForce = -rearAntiRollBarRate * rollAngle * 0.5f;
            if (corner == 3) antiRollForce = -antiRollForce; // Opposite sign for right side
        }

        return antiRollForce;
    }

    /**
     * Update wheel geometry based on suspension position
     */
    private void updateGeometry(int corner) {
        float position = suspensionPosition[corner];

        // Update camber angle
        if (corner < 2) { // Front
            camberAngles[corner] = frontCamberGain * (position / 100.0f);
        } else { // Rear
            camberAngles[corner] = rearCamberGain * (position / 100.0f);
        }

        // Update toe angle
        if (corner < 2) { // Front
            toeAngles[corner] = frontToeChange * (position / 100.0f);
        } else { // Rear
            toeAngles[corner] = rearToeChange * (position / 100.0f);
        }

        // Apply suspension type specific geometry changes
        applySuspensionGeometry(corner);
    }

    /**
     * Apply geometry changes specific to suspension type
     */
    private void applySuspensionGeometry(int corner) {
        switch (suspensionType.toLowerCase()) {
            case "macpherson":
                // MacPherson strut has more camber change
                camberAngles[corner] *= 1.3f;
                break;

            case "double_wishbone":
                // Double wishbone has better camber control
                camberAngles[corner] *= 0.8f;
                break;

            case "multi_link":
                // Multi-link has the best control
                camberAngles[corner] *= 0.6f;
                toeAngles[corner] *= 0.7f;
                break;

            case "solid_axle":
                // Solid axle has no independent geometry changes
                if (corner == 0 || corner == 1) { // Front axle
                    float avgCamber = (camberAngles[0] + camberAngles[1]) * 0.5f;
                    camberAngles[0] = avgCamber;
                    camberAngles[1] = avgCamber;
                } else { // Rear axle
                    float avgCamber = (camberAngles[2] + camberAngles[3]) * 0.5f;
                    camberAngles[2] = avgCamber;
                    camberAngles[3] = avgCamber;
                }
                break;
        }
    }

    /**
     * Apply travel limits and bump/rebound rubbers
     */
    private void applyTravelLimits(int corner, float[] suspensionForces) {
        float position = suspensionPosition[corner];
        float maxTravel = (corner < 2) ? frontTravel : rearTravel;

        // Bump rubber (compression limit)
        if (position > maxTravel * 0.8f) {
            float compressionRatio = (position - maxTravel * 0.8f) / (maxTravel * 0.2f);
            float bumpForce = bumpRubberRate * compressionRatio * compressionRatio;
            suspensionForces[corner] -= bumpForce;
        }

        // Rebound rubber (extension limit)
        if (position < -maxTravel * 0.5f) {
            float extensionRatio = (Math.abs(position) - maxTravel * 0.5f) / (maxTravel * 0.5f);
            float reboundForce = reboundRubberRate * extensionRatio * extensionRatio;
            suspensionForces[corner] += reboundForce;
        }

        // Hard limits
        suspensionPosition[corner] = Math.max(-maxTravel, Math.min(maxTravel, position));
    }

    /**
     * Adjust suspension for track conditions
     */
    public void adjustForTrackConditions(String trackType, String surface) {
        switch (trackType.toLowerCase()) {
            case "road_course":
                // Balanced setup for road courses
                setAdaptiveDamperSetting(0.6f);
                break;

            case "oval":
                // Stiffer setup for oval racing
                setAdaptiveDamperSetting(0.8f);
                increaseFrontAntiRollBar(1.2f);
                break;

            case "drag_strip":
                // Softer rear for traction
                setAdaptiveDamperSetting(0.3f);
                decreaseRearAntiRollBar(0.7f);
                break;

            case "rally":
                // Softer setup for rough surfaces
                setAdaptiveDamperSetting(0.2f);
                increaseTravel(1.5f);
                break;
        }
    }

    /**
     * Calculate roll stiffness distribution
     */
    public float getRollStiffnessDistribution() {
        float frontRollStiffness = frontAntiRollBarEnabled ? frontAntiRollBarRate : 0.0f;
        float rearRollStiffness = rearAntiRollBarEnabled ? rearAntiRollBarRate : 0.0f;
        float totalRollStiffness = frontRollStiffness + rearRollStiffness;

        return totalRollStiffness > 0 ? frontRollStiffness / totalRollStiffness : 0.5f;
    }

    /**
     * Get suspension travel percentage
     */
    public float[] getSuspensionTravelPercentage() {
        float[] percentages = new float[4];

        for (int i = 0; i < 4; i++) {
            float maxTravel = (i < 2) ? frontTravel : rearTravel;
            percentages[i] = (suspensionPosition[i] + maxTravel * 0.5f) / maxTravel;
            percentages[i] = Math.max(0.0f, Math.min(1.0f, percentages[i]));
        }

        return percentages;
    }

    // Helper methods for adjustments
    private void setAdaptiveDamperSetting(float setting) {
        if (adaptiveDampers) {
            this.adaptiveDamperSetting = Math.max(0.0f, Math.min(1.0f, setting));
        }
    }

    private void increaseFrontAntiRollBar(float multiplier) {
        this.frontAntiRollBarRate *= multiplier;
    }

    private void decreaseRearAntiRollBar(float multiplier) {
        this.rearAntiRollBarRate *= multiplier;
    }

    private void increaseTravel(float multiplier) {
        this.frontTravel *= multiplier;
        this.rearTravel *= multiplier;
    }

    // Getters and Setters
    public float getFrontSpringRate() { return frontSpringRate; }
    public void setFrontSpringRate(float frontSpringRate) { this.frontSpringRate = frontSpringRate; }

    public float getRearSpringRate() { return rearSpringRate; }
    public void setRearSpringRate(float rearSpringRate) { this.rearSpringRate = rearSpringRate; }

    public float getFrontDamperCompression() { return frontDamperCompression; }
    public void setFrontDamperCompression(float frontDamperCompression) { this.frontDamperCompression = frontDamperCompression; }

    public float getFrontDamperRebound() { return frontDamperRebound; }
    public void setFrontDamperRebound(float frontDamperRebound) { this.frontDamperRebound = frontDamperRebound; }

    public float getRearDamperCompression() { return rearDamperCompression; }
    public void setRearDamperCompression(float rearDamperCompression) { this.rearDamperCompression = rearDamperCompression; }

    public float getRearDamperRebound() { return rearDamperRebound; }
    public void setRearDamperRebound(float rearDamperRebound) { this.rearDamperRebound = rearDamperRebound; }

    public float getFrontAntiRollBarRate() { return frontAntiRollBarRate; }
    public void setFrontAntiRollBarRate(float frontAntiRollBarRate) { this.frontAntiRollBarRate = frontAntiRollBarRate; }

    public float getRearAntiRollBarRate() { return rearAntiRollBarRate; }
    public void setRearAntiRollBarRate(float rearAntiRollBarRate) { this.rearAntiRollBarRate = rearAntiRollBarRate; }

    public float getRideHeight() { return rideHeight; }
    public void setRideHeight(float rideHeight) { this.rideHeight = rideHeight; }

    public String getSuspensionType() { return suspensionType; }
    public void setSuspensionType(String suspensionType) { this.suspensionType = suspensionType; }

    public boolean isAdaptiveDampers() { return adaptiveDampers; }
    public void setAdaptiveDampers(boolean adaptiveDampers) { this.adaptiveDampers = adaptiveDampers; }

    public float getAdaptiveDamperSetting() { return adaptiveDamperSetting; }

    public float[] getSuspensionPosition() { return suspensionPosition; }
    public float[] getCamberAngles() { return camberAngles; }
    public float[] getToeAngles() { return toeAngles; }
}
